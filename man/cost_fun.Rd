% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cost-fun.R
\name{cost_fun}
\alias{cost_fun}
\title{Cost function}
\usage{
cost_fun(f, context_sensitive, vectorised = FALSE, symmetric = NA,
  has_reverse = FALSE)
}
\arguments{
\item{f}{Function defining the cost function.
If \code{context_sensitive = TRUE}, this function should take two arguments,
the first corresponding to the previous state,
and the second corresponding to the new state.
If \code{context_sensitive = FALSE}, this function should take one argument
corresponding to the new state.}

\item{context_sensitive}{Scalar Boolean;
whether the function is affected by the identity of the previous state.
If \code{FALSE}, this means the cost function only depends on the identity
of the new state.}

\item{vectorised}{Scalar Boolean;
whether or not \code{f} is vectorised.
If \code{f} is vectorised, it should take as its first input a
list of potential previous states,
with its second input being the new state, as before.
It should then return a numeric vector corresponding to the
transition cost associated with each potential previous state.}

\item{memoise}{Scalar Boolean;
whether or not the cost function should be memoised.
Defaults to \code{FALSE}, but enable this when the cost function
is time-consuming to compute and repeated transitions are anticipated.}
}
\value{
An object of class \code{cost_fun}, to be combined into a list
and passed to \code{seq_opt()}.
}
\description{
Defines a cost function to be used in \code{seq_opt()}.
A cost function defines the penalty for a given state transitions.
If multiple cost functions are provided to \code{seq_opt()}
then costs are computed for each cost function and summed
to produce the final cost.
}
