% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/seq-opt.R
\name{seq_opt}
\alias{seq_opt}
\title{Find optimal sequence}
\usage{
seq_opt(x, cost_funs, weights = 1, progress = FALSE,
  norm_cost = FALSE, exponentiate = FALSE, minimise = TRUE)
}
\arguments{
\item{x}{A nested list describing the possible states at the possible time points.
Element \code{x[[i]]} should be a list describing the states available
at timepoint \code{i}.
Element \code{x[[i]][[j]]} should be the \code{j}th possible state
at timepoint \code{i}.}

\item{cost_funs}{A list of cost functions,
with each cost function created by \code{cost_fun()}.
When applied to a state transition,
each cost function is computed, weighted by its weight parameter,
and summed to provide the total cost.
Decomposition of cost functions in this way has efficiency benefits
when some of the cost functions are context-independent
(i.e. the cost associated with moving to a state is independent of
the previous state).}

\item{progress}{Whether or not to show a progress bar.}

\item{norm_cost}{(Logical scalar)
Whether or not the cost at each transition
(conditioned on the previous state)
should be normalised to sum to 1
for the set of possible continuations.
This yields a probabilistic interpretation of the cost function.}

\item{exponentiate}{(Logical scalar)
Whether the combined cost function should be exponentiated.}

\item{minimise}{(Logical scalar)
Whether the cost function should be minimised or maximised.}
}
\value{
A list where element \code{i} corresponds to the optimal
state at timepoint \code{i}.
}
\description{
Given a list of timepoints and corresponding lists of possible states,
efficiently finds an optimal state sequence that minimises (or maximises)
 an arbitrary transition cost function.
The implementation uses dynamic programming to achieve complexity
linear in the sequence length
and quadratic in the number of possible states.
}
